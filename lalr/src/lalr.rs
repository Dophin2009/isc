use crate::lr1::{LR1Table, LRConflict};
use crate::Grammar;

use std::collections::BTreeSet;

/// Enum to represent three possible lookahead types when computing LALR(1) item kernels.
#[derive(Debug, Ord, PartialOrd, Eq, PartialEq)]
enum LR1Lookahead<'a, T> {
    /// A terminal from the grammar.
    Terminal(&'a T),
    /// The endmarker terminal.
    Endmarker,
    /// A symbol not in the grammar (#), used to determine which items lookaheads are propogated
    /// to.
    NonSymbol,
}

impl<T, N, A> Grammar<T, N, A>
where
    T: Ord,
    N: Ord,
{
    /// Construct an LALR(1) parse table for the grammar.
    ///
    /// Implements **Algorithm 4.63** to efficiently compute the kernels of the LALR(1) collection
    /// of item sets for a grammar.
    pub fn lalr1_table_by_lr0<'a>(
        &'a self,
    ) -> Result<LR1Table<'a, T, N, A>, LRConflict<'a, T, N, A>> {
        // Compute the LR(0) item set.
        let mut lr0_automaton = self.lr0_automaton();

        // Compute the first sets.
        let first_sets = self.first_sets();

        // Remove non-kernel items.
        for state in lr0_automaton.states.iter_mut() {
            state.items = state
                .items
                .iter()
                // Kernel items include the initial item, S' -> .S, and all items whose dots are
                // not at the left end.
                .filter(|item| *item.lhs == self.start || item.pos != 0)
                .cloned()
                .collect();
        }

        // Determine lookaheads spontaneously generated by items in I for kernel items in GOTO(I,X)
        // and the items in I from which lookaheads are propagated to kernel items in GOTO(I,X).
        for kernel in lr0_automaton.states {
            for item in kernel.items {
                // J := CLOSURE({[A -> α.β, #]})
                let closure = {
                    let mut init_set = BTreeSet::new();
                    init_set.insert((item.clone(), LR1Lookahead::NonSymbol));
                    self.lr1_closure(&mut init_set, &first_sets);
                    init_set
                };

                for (new_item, new_la) in closure {
                    let next_symbol = match new_item.next_symbol() {
                        Some(sy) => sy,
                        None => continue,
                    };

                    match new_la {
                        // If [B -> γ·Xδ, a] is in J, and a is not #, conclude that lookahead a is
                        // generated spontaneously for item B -> γX·δ in GOTO(I, X).
                        LR1Lookahead::Terminal(t) => {}
                        LR1Lookahead::Endmarker => {}
                        // If [B -> γ·Xδ, #] is in J,  conclude that lookahead a is generated
                        // spontaneously for item B -> γX·δ in GOTO(I, X).
                        LR1Lookahead::NonSymbol => {}
                    }
                }
            }
        }

        Ok(LR1Table {
            states: Vec::new(),
            initial: 0,
        })
    }
}
